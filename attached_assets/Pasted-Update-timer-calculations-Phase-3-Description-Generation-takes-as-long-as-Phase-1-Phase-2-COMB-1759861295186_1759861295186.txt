Update timer calculations - Phase 3 (Description Generation) takes as long as Phase 1 + Phase 2 COMBINED.

ACCURATE TIMING:

Phase 1 (Upload): ~2.5 seconds per item
Phase 2 (Analysis): ~2.5 seconds per item  
Phase 3 (Descriptions): ~5-6 seconds per item (equal to Phase 1 + Phase 2)

For 14 items:
- Phase 1: 14 √ó 2.5 = 35 seconds
- Phase 2: 14 √ó 2.5 = 35 seconds
- Phase 3: 14 √ó 5.5 = 77 seconds (‚â• Phase 1 + Phase 2)
- TOTAL: ~147 seconds (2.5 minutes)

TIMER CALCULATION UPDATE:
```javascript
const TIMING_CONFIG = {
  UPLOAD_TIME_PER_ITEM: 2.5,      // seconds
  ANALYSIS_TIME_PER_ITEM: 2.5,    // seconds
  DESCRIPTION_TIME_PER_ITEM: 5.5, // seconds (equal to or greater than upload + analysis)
};

const calculatePhaseTime = (itemCount, phase) => {
  switch(phase) {
    case 'upload':
      return Math.ceil(itemCount * TIMING_CONFIG.UPLOAD_TIME_PER_ITEM);
    case 'analysis':
      return Math.ceil(itemCount * TIMING_CONFIG.ANALYSIS_TIME_PER_ITEM);
    case 'description':
      // Phase 3 takes as long as Phase 1 + Phase 2 combined
      return Math.ceil(itemCount * TIMING_CONFIG.DESCRIPTION_TIME_PER_ITEM);
    default:
      return 0;
  }
};

const calculateTotalTime = (itemCount) => {
  const uploadTime = calculatePhaseTime(itemCount, 'upload');
  const analysisTime = calculatePhaseTime(itemCount, 'analysis');
  const descriptionTime = calculatePhaseTime(itemCount, 'description');
  
  return {
    phase1: uploadTime,
    phase2: analysisTime,
    phase3: descriptionTime,
    total: uploadTime + analysisTime + descriptionTime,
    formatted: formatTime(uploadTime + analysisTime + descriptionTime)
  };
};

// Example for 14 items:
const timing = calculateTotalTime(14);
// {
//   phase1: 35,
//   phase2: 35, 
//   phase3: 77,
//   total: 147,
//   formatted: "2:27"
// }
SHOW PHASE TIME ESTIMATES UPFRONT:
javascriptconst ProcessingStartModal = ({ itemCount }) => {
  const timing = calculateTotalTime(itemCount);
  
  return (
    <div className="processing-start">
      <h2>Ready to Process {itemCount} Items</h2>
      
      <div className="time-breakdown">
        <h3>Estimated Processing Time: {timing.formatted}</h3>
        
        <div className="phase-times">
          <div className="phase-time">
            <span className="icon">üì§</span>
            <span className="label">Upload Photos</span>
            <span className="duration">~{timing.phase1}s</span>
          </div>
          
          <div className="phase-time">
            <span className="icon">üîç</span>
            <span className="label">AI Analysis</span>
            <span className="duration">~{timing.phase2}s</span>
          </div>
          
          <div className="phase-time highlight">
            <span className="icon">‚úçÔ∏è</span>
            <span className="label">Generate Descriptions</span>
            <span className="duration">~{timing.phase3}s</span>
            <span className="note">Most detailed step</span>
          </div>
        </div>
      </div>
      
      <p className="info">
        Phase 3 takes the longest because AI is creating detailed 
        descriptions, meta tags, SEO keywords, price suggestions, 
        and category assignments for each item.
      </p>
      
      <button onClick={handleStartProcessing}>Start Processing</button>
    </div>
  );
};
DYNAMIC REMAINING TIME CALCULATION:
javascriptconst calculateRemainingTime = (startTime, completedItems, totalItems, timePerItem) => {
  if (completedItems === 0) {
    return Math.ceil(totalItems * timePerItem);
  }
  
  // Calculate actual time taken so far
  const elapsedSeconds = (Date.now() - startTime) / 1000;
  const actualTimePerItem = elapsedSeconds / completedItems;
  
  // Use actual performance for remaining items
  const remainingItems = totalItems - completedItems;
  return Math.ceil(remainingItems * actualTimePerItem);
};

// Usage in Phase 3:
const [descriptionStartTime, setDescriptionStartTime] = useState(null);

const processDescriptions = async (items) => {
  const startTime = Date.now();
  setDescriptionStartTime(startTime);
  
  for (let i = 0; i < items.length; i++) {
    // Update progress
    const remaining = calculateRemainingTime(
      startTime, 
      i, 
      items.length, 
      TIMING_CONFIG.DESCRIPTION_TIME_PER_ITEM
    );
    
    setDescriptionProgress({
      current: i,
      total: items.length,
      timeRemaining: remaining,
      percentComplete: Math.round((i / items.length) * 100)
    });
    
    // Generate description (takes ~5.5 seconds)
    await generateAIDescription(items[i]);
    
    // Update completed
    setDescriptionProgress({
      current: i + 1,
      total: items.length,
      timeRemaining: calculateRemainingTime(
        startTime, 
        i + 1, 
        items.length, 
        TIMING_CONFIG.DESCRIPTION_TIME_PER_ITEM
      ),
      percentComplete: Math.round(((i + 1) / items.length) * 100)
    });
  }
};
PROGRESS BAR WITH TIME WEIGHTING:
Show overall progress weighted by time, not just item count:
javascriptconst OverallProgress = ({ phase, uploadProgress, analysisProgress, descriptionProgress, totalItems }) => {
  const timing = calculateTotalTime(totalItems);
  const totalTime = timing.total;
  
  // Calculate time-weighted progress
  let completedTime = 0;
  
  if (phase === 'upload') {
    completedTime = (uploadProgress.current / uploadProgress.total) * timing.phase1;
  } else if (phase === 'analysis') {
    completedTime = timing.phase1 + 
                   ((analysisProgress.current / analysisProgress.total) * timing.phase2);
  } else if (phase === 'description') {
    completedTime = timing.phase1 + timing.phase2 + 
                   ((descriptionProgress.current / descriptionProgress.total) * timing.phase3);
  }
  
  const overallPercent = Math.round((completedTime / totalTime) * 100);
  
  return (
    <div className="overall-progress">
      <h3>Overall Progress</h3>
      <div className="progress-bar large">
        <div 
          className="progress-fill overall"
          style={{ width: `${overallPercent}%` }}
        >
          {overallPercent}%
        </div>
      </div>
      <p>Time completed: {formatTime(completedTime)} of {formatTime(totalTime)}</p>
    </div>
  );
};
PHASE 3 PROGRESS DISPLAY:
javascriptconst DescriptionGenerationProgress = ({ current, total, timeRemaining }) => {
  const percent = Math.round((current / total) * 100);
  const expectedTotal = Math.ceil(total * TIMING_CONFIG.DESCRIPTION_TIME_PER_ITEM);
  
  return (
    <div className="description-progress">
      <h3>Generating Descriptions & Meta Tags</h3>
      <p>Creating detailed content for item {current} of {total}</p>
      
      {/* Show this phase takes longest */}
      <div className="phase-info">
        <span className="icon">‚è±Ô∏è</span>
        <span className="text">
          This is the most detailed phase (~{expectedTotal}s total)
        </span>
      </div>
      
      <div className="progress-bar">
        <div 
          className="progress-fill description-phase"
          style={{ width: `${percent}%` }}
        >
          {percent}%
        </div>
      </div>
      
      <div className="progress-details">
        <span>{current} of {total} descriptions generated</span>
        <span className="time-remaining">
          {formatTime(timeRemaining)} remaining
        </span>
      </div>
      
      <div className="phase-explanation">
        <p>
          <strong>Why this takes longer:</strong> AI is writing professional 
          titles, detailed descriptions (2-3 sentences), selecting accurate 
          categories, analyzing condition, suggesting competitive prices, and 
          creating SEO-optimized meta tags for maximum visibility.
        </p>
      </div>
    </div>
  );
};
VISUAL COMPARISON:
Phase Timing for 14 Items:

Phase 1: Upload        [‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 35s  (24%)
Phase 2: Analysis      [‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 35s  (24%)
Phase 3: Descriptions  [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 77s  (52%)
                       ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Total:                                    147s (100%)

Phase 3 is ~52% of total time (longer than Phase 1 + 2)
EDUCATIONAL TIP ABOUT PHASE 3 TIMING:
Add to tips array:
javascript{
  icon: "‚è±Ô∏è",
  title: "Why Description Generation Takes Longer",
  description: "Creating detailed descriptions, meta tags, and SEO keywords requires more AI processing than basic image analysis. This extra time ensures your listings are professional, searchable, and optimized for sales."
}
UPDATE TIMER CONSTANTS:
javascriptconst TIMING_CONFIG = {
  // Phase 1: Upload
  UPLOAD_TIME_PER_ITEM: 2.5,
  
  // Phase 2: Quick analysis
  ANALYSIS_TIME_PER_ITEM: 2.5,
  
  // Phase 3: Detailed generation (‚â• Phase 1 + Phase 2)
  DESCRIPTION_TIME_PER_ITEM: 5.5, // Or use: UPLOAD + ANALYSIS + 0.5 buffer
  
  // Total per item
  TOTAL_TIME_PER_ITEM: 10.5 // 2.5 + 2.5 + 5.5
};
This accurately reflects that Phase 3 is the longest and most intensive phase, taking as long or longer than the first two phases combined.
Implement accurate Phase 3 timing calculation now and test with 14 items to verify timer shows ~77 seconds for Phase 3.